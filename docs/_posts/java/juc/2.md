# 并发编程-尚硅谷

- 背景
- JMM内存模型
- 并发编程三大特性
- 线程通信的相关知识
- 理解java中的锁
- JUC-同步工具类使用
- 理解线程池的原理



# 背景

在计算机早期，在没有线程的年代，在同一个进程中，程序的处理流程都是顺序的，下一个流程的开始必须等待上一个流程的结束，如果其中某一个流程非常耗时，那么会影响整个流程的处理时间

![1585712700471](/v-blog/img/java/middle-java/juc/1585712700471.png)

思考：怎么优化呢

将耗时的部分改成异步处理

## 线程的出现 
有了进程以后，为什么还要发明线程呢？ 

1. 在多核CPU中，利用多线程可以实现并行 执行 
2. 同步处理的流程容易发生阻塞，可以用线程来实现异步处理，提高程序处理实时性
3. 线程可以认为是轻量级的进程，所以线程的创建、销毁 比进程更快 （性能开销更小）

# 多线程应用

## java中如何应用多线程

* 继承Thread

```java
public class MyThread extends Thread {

    @Override
    public void run(){
        System.out.println(Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        MyThread myThread = new MyThread();

        MyThread myThread1 = new MyThread();

        myThread.start();

        myThread1.start();
    }
}
```

* 实现Runnable

```java
public class MyRunnable implements Runnable {

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        
        new Thread(myRunnable).start();
        new Thread(myRunnable).start();
    }
}
```

> Thread和Runnable区别？
>
> 1、java是单继承，如果一个类已经继承了父类，那么无法继承Thread,所以需要实现Runnable
>
> 2、Thread实现了Runnable接口
>
> 3、实现Runnable资源可以共享

* 实现Callable

```java
public class MyCallable implements Callable<String> {

    @Override
    public String call() throws Exception {
        System.out.println(Thread.currentThread().getName());
        return "11";
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyCallable myCallable = new MyCallable();
        //线程池后面会详细的说明，先知道有这么一个东西即可
        ExecutorService executorService = Executors.newFixedThreadPool(1);
        Future<String> future = executorService.submit(myCallable);
        
        System.out.println(future.get());
    }
}
```

> Callable跟其它两种线程的区别？
>
> 说白了：Callable有返回值

## 线程的状态

- 线程的状态

  线程一共有 6 种状态（NEW、RUNNABLE、BLOCKED、 WAITING、TIME_WAITING、TERMINATED）

>NEW：初始状态，线程被创建，但是还没有调用start方法 
>
>RUNNABLED：运行状态，调用start方式让线程处于“运行中” 
>
>BLOCKED：阻塞状态，表示线程进入等待状态,也就是线程 因为某种原因放弃了CPU使用权，阻塞也分为几种情况 
>
>➢ 同步阻塞：运行的线程在获取锁时，若该锁被其他线程占用了，那么当前线程会阻塞
>
>![1585704992434](/v-blog/img/java/middle-java/juc/1585704992434.png)
>
>➢ 其他阻塞：运行的线程执行Thread.sleep或者t.join方法时，称为其他阻塞
>
>> Thread.sleep(1000)
>
>WAITING:调用wait等方法等待,等待唤醒(notify或notifyAll)
>
>> wait();
>
>TIME_WAITING：超时等待状态，等待另一个线程在指定的时间访问唤醒,超时以后线程状态就是TIME_WAITING
>
>> wait(2000)
>
>TERMINATED：终止状态，表示当前线程执行完毕 
>
>> run方法执行完毕



## 线程的启动

前面我们通过一些案例演示了线程的启动，也就是调用 start()方法去启动一个线程。

我们看到调用 start 方法实际上是调用一个 native 方法 start0()来启动一个线程。

## 线程的中断

要优雅的去中断一个线程，在线程中提供了一个 interrupt 方法 

```java
public class InterrupDemo {

    static int i;

    public static void main(String[] args) throws InterruptedException {

        Thread t = new Thread(()->{
            //isInterrupted()默认是false,如果当前线程调用了interrupt()之后，isInterrupted()变成true
            //说白了，就是判断有没有调用线程中断方法
            while(! Thread.currentThread().isInterrupted()){
                i++;
            }
            System.out.println("while之外的输出:"+i);
        },"InterrupDemo");

        t.start();

        Thread.sleep(100);

        t.interrupt();
    }

}
```



## Thread.sleep

Thread.sleep（）：让当前的流程睡眠多少毫秒

```java
public class ThreadSleepDemo {

    public static void main(String[] args) throws InterruptedException {
        System.out.println("开始:"+new Date());

        Thread.sleep(2000);// 2 秒

        System.out.println("结束:"+new Date());

    }

}
```

## Thread.join

Thread.join:等待某一个线程执行结束

```java
public class ThreadJoinDemo {

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()->{
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("t1");
        });

        t1.start();
        //需求：让第二线程必须等到第一个线程执行完之后再执行
        t1.join();//阻塞，等到t1线程执行完毕

        Thread t2 = new Thread(()->{
            System.out.println("t2");
        });
        t2.start();
        //期望结果：t1永远都在t2前面打印
    }
}
```



# JMM内存模型

1. Java内存模型（简称：JMM）定义了共享内存中多线程程序读写操作 的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正 确性，它解决了 CPU 多级缓存、处理器优化、指令重排序 导致的内存访问问题

   总结：JMM让java程序与硬件指令进行了隔离

2. 由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存，用于存储线程私有的数据。而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问。

   总结：JMM把内存分为两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存）

3. 线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程无法访问其它线程的工作内存，线程间的通信(传值)必须通过主内存来完成，

   总结：线程跟线程之间是相互隔离，线程跟线程交互需要通过主内存

其简要访问过程如下图：

![1585712787516](/v-blog/img/java/middle-java/juc/1585712787516.png)

![1585712770127](/v-blog/img/java/middle-java/juc/1585712770127.png)

```
关于JMM中的主内存和工作内存说明

- 主内存
  主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量，也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。
- 工作内存
  每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会在自己的工作内存中创建属于当前线程的本地变量。注意由于工作内存是每个线程的私有数据，线程之间的工作内存无法相互访问，因此存储在工作内存的数据不存在线程安全问题。
```

* JMM 内存指令同步的流程

![1585712821063](/v-blog/img/java/middle-java/juc/1585712821063.png)

> 举例：线程操作一个变量分两步
>
> 1.主内存变量到工作内存到线程使用：Lock-->Read-->Load-->use-->线程使用
>
> 2.线程操作变量完成同步到工作内存，工作内存刷新到主内存过程：：Assign-->Store-->Write--->Unlock

```
1. lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态

2. unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定

3. read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用

4. load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中

5. use(使用)：作用于工作内存的变量，use指令表示的是线程去加载工作内存的变量，从而进行变量操作

6. assign(赋值)：作用于工作内存的变量，私有线程运行结束之后需要把运行完最新的数据重新赋值给工作内存变量

7. store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write操作

8. write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中
```



# Java并发编程三大特性

* 原子性

一个线程在CPU中操作不可暂定，也不可中断，要不执行完成，要不不执行

```java
public class TicketDemo {

    int ticketNum = 10;

    public synchronized void getTicket(){

        if(ticketNum <= 0){
            return ;
        }
        System.out.println(Thread.currentThread().getName()+"抢到一张票,剩余:"+ticketNum);
        ticketNum--;
    }

    public static void main(String[] args) {
        TicketDemo demo = new TicketDemo();
        for(int i=0;i<20;i++){
            new Thread(demo::getTicket).start();
        }
        //结论：不是原子操作，怎么保证原子操作呢？
    }

}
```

>不是原子操作，怎么保证原子操作呢？
>
>JMM对原子性的保证：
>
>1.synchronized：同步加锁
>
>2.JUC里面的lock：加锁
>
>

* 可见性

多个线程访问同一个变量是，一个线程修改这个变量的值，其它线程能够看到修改之后的值

```java
public class VolatileDemo {

    private volatile static boolean flag = false;

    public static void main(String[] args) throws InterruptedException {

        new Thread(()->{
            while(!flag){

            }
            System.out.println("第一个线程执行完毕...");
        }).start();

        Thread.sleep(100);

        new Thread(()->{
            flag = true;//思考：第一个线程会不会跳槽while循环，输出System.out.println("第一个线程执行完毕...");
            System.out.println("第二线程执行完毕...");
        }).start();

    }

}
```

> JMM对可见性的保证：
>
> 加Volatile关键字
>
> 对Volatile变量进行**写操作**的时候，会在写操作之后加一个指令（store）,会将数据强制刷新到主内存中
>
> 对Volatile变量进行**读操作**的时候，会在读操作之前加一个指令（load），强制每次都去主内存拉取最新的变量值

* 有序性

```
程序执行的顺序按照代码的先后顺序执行。
一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。如下：
int a=2; //1 

int b=3; //2 

int rs=a*b; //3

则因为指令重排序，他还可能执行顺序为 1-2-3,2-1-3
 但是绝对不会是3-1-2/3-2-1这种顺序,因为这打破了依赖关系。
```

# volatile

```
volatile 关键字的作用是变量在多个线程之间可见。并且能够保证所修饰变量的有序性：
1、 保证变量的可见性：当一个被volatile关键字修饰的变量被一个线程修改的时候，其他线程可以立刻得到修改之后的结果。
原理：当一个线程向被volatile关键字修饰的变量写入数据的时候，虚拟机会强制它被值刷新到主内存中。当一个线程用到被volatile关键字修饰的值的时候，虚拟机会强制要求它从主内存中读取。保证读取的值是最新的值
2、 防止指令重排序：指令重排序是编译器和处理器为了高效对程序进行优化的手段，它只能保证程序执行的结果时正确的，但是无法保证程序的操作顺序与代码顺序一致。这在单线程中不会构成问题，但是在多线程中就会出现问题。字段加入voliate，就是为了防止指令重排序。
```

**多线程环境重排序问题**

```java
class Test{
    
    int a = 0;
    boolean flag = false;
    //写操作
    public void write(){
       a = 1;   // 1
       flag = true;   //2
    }
    //读操作
    public void reader(){
        if(flag){ // 3
            int i = a+1;  //4
        }
    }
    //假设write方法和reader在不同线程环境下运行，可能write会被其它线程优先执行，由于指令重排序会把2放在1前面，那么2会优于1先执行，此时另外一个线程执行reader方法，由于flag=ture,但是a=0,int i的结果不是我们期望的结果
}
```

# 理解线程通信

wait：表示持有对象锁的线程 释放对象锁权限，并且释 放 cpu 资源并进入阻塞状态。

notify: 唤醒一个阻塞状态的线程

notifyAll: 唤醒全部阻塞状态的线程

* ThreadA 

```
public class ThreadA extends Thread {

    private Object obj;

    public ThreadA(Object obj){
        this.obj = obj;
    }

    @Override
    public void run(){
        synchronized (obj){
            System.out.println(Thread.currentThread().getName()+"ThreadA开始了....");
            try {
                obj.wait();//阻塞，等待唤醒
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+"ThreadA结束了....");
        }
    }

}
```

* ThreadB

```java
public class ThreadB extends Thread {

    private Object obj;

    public ThreadB(Object obj){
        this.obj = obj;
    }

    @Override
    public void run(){
        synchronized (obj){
            System.out.println(Thread.currentThread().getName()+"ThreadB开始了....");
            obj.notify();//唤醒
            System.out.println(Thread.currentThread().getName()+"ThreadB结束了....");
        }
    }

}
```

* NotifyWaitDemo

```java
public class NotifyWaitDemo {

    public static void main(String[] args) throws InterruptedException {
        Object obj = new Object();
        new ThreadA(obj).start();

        Thread.sleep(10);

        new ThreadB(obj).start();
    }

}
```

# 理解java中的锁

第一个问题： 什么是线程安全问题？

```
多线程操作共享变量，导致访问数据出问题。
```

换个方式提问：出现线程安全问题的条件

```
1、多线程
2、共享变量
```

## synchronized

**synchronized 的基本认识**

在多线程并发编程中synchronized一直是元老级角色，很 多人都会称呼它为重量级锁

- synchronize使用方式

1、修饰在实例方法：作用当前实例加锁

```java
public class TicketDemo{

	public synchronized void getTicket(){
        try {
            ...
```

2、修饰在静态方法:作用当前类加锁

```java
public class TicketDemo1 {

    static int ticketNum = 10;

    public synchronized static void getTicket() {
          ....
    }

}
```

3、修饰在代码块:进入同 步块加锁

```java
public class TicketDemo1 {

    static int ticketNum = 10;

    public   void getTicket() {
        synchronized (TicketDemo1.class) {
           ....
        }
    }

}
```

- **工作原理**

JVM 是通过进入、退出对象监视器( Monitor )来实现对方法、同步块的同步的。

> 通过javap -c TickerDemo.class 反编译指令查看

![1585729940477](/v-blog/img/java/middle-java/juc/1585729940477.png)

* 死锁

```java
public class DeadLockDemo {


    static Object o1 = new Object();
    static Object o2 = new Object();

    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (o1){//第一个线程获得o1锁对象成功
                    System.out.println("thread 1 get o1");
                    try {
                        Thread.sleep(100);
                        synchronized (o2){//第一个线程获取o2锁对象的时候发现o2锁处于了Monitor状态，那么需要等待o2锁释放吧
                            System.out.println("thread1 get o2");
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                }
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (o2){//第二个线程获得o2锁对象成功
                    System.out.println("thread 2 get o2");
                    try {
                        Thread.sleep(100);
                        synchronized (o1){//第二个线程获取o1锁对象的时候发现o1锁处于了Monitor状态，那么需要等待o1锁释放吧
                            System.out.println("thread2 get o1");
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                }
            }
        }).start();
       
    }

}
```

> 第一个线程里面需要等待第二个线程所释放，而第二个线程里面需要等待第一个线程锁释放，造成两个线程相互等待，这就是死锁

## Lock

- **J.U.C 简介**

```
Java.util.concurrent 是在并发编程中比较常用的工具类，里面包含很多用来在并发场景中使用的工具类。比如线程池、阻塞队列、同步器、并发集合等等
```

> **Doug Lea**

**可重入锁ReentrantLock**

重入锁: 表示支持重新进入的锁，调用 lock 方 法获取了锁之后，再次调用 lock，是不会再阻塞，内部直接增加重入次数 就行了，标识这个线程已经重复获取一把锁而不需要等待锁的释放，比如递归调用

- #### lock锁用法

  ```java
  	Lock lock  = new ReentrantLock();
  try{
        lock.lock();
  //可能会出现线程安全的操作
    }finally{
  	//尽量在finally中释放锁
  	
      lock.unlock();
    }
  ```

  

- **API方法**

  - lock()用来获取锁
  - unlock()释放锁，最好在finally块中释放

  代码改进

  ```java
  public class TicketDemo {
  
      int ticketNum = 10;
  	Lock lock = new ReentrantLock();
      private void getTicket() {
          try {
              lock.lock();
              if (ticketNum <= 0) {
                  return;
              }
              System.out.println(Thread.currentThread().getName() + ":抢到了一张票，剩余：" + ticketNum);
              ticketNum--;
          }finally {
              lock.unlock();
          }
      }
  
      public static void main(String[] args) {
          TicketDemo demo = new TicketDemo();
          for (int i = 0; i < 20; i++) {
              new Thread(demo::getTicket).start();
          }
         
      }
  
  }
  ```

- lock锁与synchronized比较

```
1. synchronized 是内部锁,自动化的上锁与释放锁,而lock是手动的,需要人为的上锁和释放锁,lock比较灵活,但是代码量多
2、lock是一个接口，而synchronized是Java中的关键字
3、性能上来说，在资源竞争不激烈的情形下，Lock性能稍微比synchronized差点。但是当并发非常激烈的时候，synchronized的性能就会下降几十倍。而ReentrantLock确还能维持常态。
```

# JUC-同步工具类

## CountDownLatch

- 介绍

```
countdownlatch 是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完毕再执行
```

- API

| CountDownLatch类          |                                                              |
| ------------------------- | ------------------------------------------------------------ |
| CountDownLatch(int count) | 创建CountDownLatch 实例并设置预定计数次数                    |
| void countDown()          | 如果当前计数大于零，调用一次内部的计数次数减1                |
| void await()              | 如果内部的计数器大于0则一直等待，除非线程被中断。如果当前的计数为零，则唤醒当前阻塞 |

- 案例

```java
public class CountDownLatchDemo{

   public static void main(String[] args) throws InterruptedException {
       CountDownLatch countDownLatch =new CountDownLatch(3);
        new Thread(()->{
            System.out.println("挂号");
            countDownLatch.countDown(); //3-1=2
        }).start();
        new Thread(()->{
            System.out.println("看病");
            countDownLatch.countDown();//2-1=1
        }).start();
        new Thread(()->{
            System.out.println("拿药");
            countDownLatch.countDown();//1-1=0
        }).start();
        countDownLatch.await();// 阻塞，直到内部计数器为0

        System.out.println("回家...");
    }
}
```

## **信号量 Semaphore ** 

[ˈseməfɔːr] 

- 介绍

```
限制访问某些资源的线程数量，比如某商场就 5 个停车位，每个停车位只能停一辆车，如果这个时候来了 10 辆车，必须要等前面有空的车位才能进入
```

- api

|                            |                                                              |
| -------------------------- | ------------------------------------------------------------ |
| ==Semaphore(int permits)== | permits是允许同时运行的线程数目,创建指定数据线程的信号量     |
| ==void acquire()==         | 方法阻塞，直到申请获取到许可证才可以运行当前线程             |
| ==void release()==         | 释放当前线程一个阻塞的 `acquire()` 方法，方法增加一个许可证,阻塞的线程会获取到这个许可证 |

- 案例

```java
public class SemaphoreDemo {
    static class Car extends  Thread{
        private int num;
        private Semaphore semaphore;

        public Car(int num, Semaphore semaphore) {
            this.num = num;
            this.semaphore = semaphore;
        }
        public void run(){
            try {
                semaphore.acquire(); //获得一个令牌, 如果拿不到令牌，就会阻塞
                System.out.println("第"+num+" 抢占一个车位");
                Thread.sleep(2000);
                System.out.println("第"+num+" 开走喽");
                semaphore.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        Semaphore semaphore=new Semaphore(5);//令牌
        for(int i=0;i<10;i++){
            new Car(i,semaphore).start();
        }
    }
    
}
```

# 理解线程池与原理

- 什么是线程池

```
在 Java 中，创建和销毁线程需要消耗很大的系统资源，线程池的核心逻辑是提前创建好若干个线程。如果有任务需要处理，则交给线程池中的线程来执行就行，任务处理完以后这个线程不会被销毁，而是等待后续分配任务。同时通过线程池来重复管理线程还可以避免创建线程所带来的性能开销
```

- 线程池的优势

```
1. 避免创建线程和销毁线程的性能开销
2. 提高响应速度
```

- Java 中提供四种线程池(Executors)

```
newFixedThreadPool：该方法返回一个固定数量的线程池，特点就是可以重用固定数量线程的线程池使用
newSingleThreadExecutor: 创建一个线程的线程池，特点是使用单个工作线程执行任务
newCachedThreadPool：不限制容量的线程池，特点是可以根据需要来创建新的线程执行任务，没有特定的corePool
newScheduledThreadPool: 创建一个可以指定线程的数量的线程池，特点一个定时功能的线程池。
```

**newFixedThreadPool**

```java
//线程池只会有两个线程执行任务
public static void main(String[] args) {
        // 创建一个固定大小的线程池
        ExecutorService es = Executors.newFixedThreadPool(2);

        for (int i = 0; i < 10; i++) {
            es.execute(()->{
                try {
                    Thread.sleep(400);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName());
            });
        }
        es.shutdown();
}
```

**newSingleThreadExecutor**

```java
//线程池只有1个线程执行任务
public static void main(String[] args) {
        // 创建线程池
        ExecutorService es = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 10; i++) {
            es.execute(()->{
                System.out.println(Thread.currentThread().getName());
            });
        }
        es.shutdown();
    }
```

**newCachedThreadPool**

```java
// 无限大小线程池 jvm自动回收
public static void main(String[] args) {
        // 创建线程池
        ExecutorService es = Executors.newCachedThreadPool();
        for (int i = 0; i < 10; i++) {
            es.execute(()->{
                System.out.println(Thread.currentThread().getName() );
            });
        }
        es.shutdown();
}
```

**newScheduledThreadPool**

```java
 public static void main(String[] args) {

        //任务线程池
        ScheduledExecutorService service =  Executors.newScheduledThreadPool(5);
        //第一个参数：执行线程
        //第二个参数：初始化延迟时间
        //第三个参数：第二次以后最小执行任务的间隔时间
        //第四个参数：时间单位
        System.out.println("初始化："+new Date());
        service.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()+"--"+new Date());
            }
        },3,2, TimeUnit.SECONDS);
    }
```

- 案例

```java
public class TaskTest implements Runnable {

    @Override
    public void run() {
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName());
    }
    
    static ExecutorService service= Executors.newFixedThreadPool(3);
    public static void main(String[] args) {
        for(int i=0;i<100;i++) {
            service.execute(new TaskTest());
        }
        service.shutdown();
    }

}
```



- **ThreadpoolExecutor** 

上面提到的四种线程池的构建，都是基于 ThreadpoolExecutor 来构建的,构造函数参数介绍

```java
public ThreadPoolExecutor(int corePoolSize,//核心线程数
                          int maximumPoolSize,//最大线程数
                          long keepAliveTime,//线程执行和存活时间
                          TimeUnit unit,//线程执行和存活时间单位
                          BlockingQueue<Runnable> workQueue,//任务队列
                          ThreadFactory threadFactory,//线程创建工厂
                          RejectedExecutionHandler handler//队列满了,执行的拒绝策略) {
     ...
}
```

##### 具体参数介绍

| 序号 | 名称            | 类型                     | 含义             |
| ---- | --------------- | ------------------------ | ---------------- |
| 1    | corePoolSize    | int                      | 核心线程池大小   |
| 2    | maximumPoolSize | int                      | 最大线程池大小   |
| 3    | keepAliveTime   | long                     | 线程最大空闲时间 |
| 4    | unit            | TimeUnit                 | 时间单位         |
| 5    | workQueue       | `BlockingQueue<Runnable>`  | 任务队列         |
| 6    | threadFactory   | ThreadFactory            | 线程创建工厂     |
| 7    | handler         | RejectedExecutionHandler | 拒绝策略         |

##### corePoolSize 核心线程池大小

corePoolSize（线程池的基本大小）：线程池内部最少需要维护的线程大小



##### maximumPoolSize 最大线程池大小

maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并
且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如
果使用了无界的任务队列这个参数就没什么效果。



##### keepAliveTime 线程活动保持时间

线程池里面的工作线程空闲后，保持存活的时间。



##### TimeUnit 时间单位

TimeUnit是java.util.concurrent包下面的一个类，表示给定单元粒度的时间段

| 单位                  | 含义                 |
| --------------------- | -------------------- |
| TimeUnit.DAYS         | 天                   |
| TimeUnit.HOURS        | 小时                 |
| TimeUnit.MINUTES      | 分钟                 |
| TimeUnit.SECONDS      | 秒                   |
| TimeUnit.MILLISECONDS | 毫秒                 |
| TimeUnit.MICROSECONDS | 微妙（千分之一毫秒） |
| TimeUnit.NANOSECONDS  | 纳秒（千分之一微秒） |



##### workQueue 任务队列

BlockingQueue是一个接口，用于保存等待执行的任务的阻塞队列，以下是实现类

queue: [kjuː] 

| BlockingQueue接口实现类 | 含义                                                         |
| :---------------------- | ------------------------------------------------------------ |
| ArrayBlockingQueue      | 有界队列，数组结构的有界阻塞队列，FIFO（先进先出）           |
| LinkedBlockingQueue     | 链表结构的阻塞队列，此队列按FIFO，吞吐量通常要高于ArrayBlockingQueue。LinkedBlockingQueue会默认为Integer.MAX_VALUE容量，21亿多，也相当于无界队列了 |
| SynchronousQueue        | 不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。 |
| PriorityBlockingQueue   | 具有优先级的无界阻塞队列                                     |





##### ThreadFactory 线程创建工厂

ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字



**RejectedExecutionHandler 饱和拒绝策略**

RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和，那么可以采取饱和策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在jdk中Java线程池框架提供了以下4种策略

| 策略类              | 含义                                                       |
| ------------------- | ---------------------------------------------------------- |
| AbortPolicy         | 默认测策略，直接抛出RejectedExecutionException运行时异常   |
| CallerRunsPolicy    | 这个策略重试当前的任务，直到成功。                         |
| DiscardOldestPolicy | 抛弃队列里面等待最久的一个任务，<br>然后把新的任务加到队列 |
| DiscardPolicy       | 不处理，丢弃掉                                             |

* 案例

```java
public class MyTask implements Runnable {

    private int taskId;
    private String taskName;

    public MyTask(int taskId, String taskName) {
        this.taskId = taskId;
        this.taskName = taskName;
    }

    public int getTaskId() {
        return taskId;
    }

    public void setTaskId(int taskId) {
        this.taskId = taskId;
    }

    public String getTaskName() {
        return taskName;
    }

    public void setTaskName(String taskName) {
        this.taskName = taskName;
    }

    @Override
    public void run() {
        System.out.println("run taskId="+this.taskId+",Thread:"+Thread.currentThread().getId());
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public String toString(){
        return Integer.toString(this.taskId);
    }
}
```

```java
public class ThreadPoolExecutorDemo {

    public static void main(String[] args) {
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                2,//核心线程数
                3,//maxpoolsize
                30,//空闲线程存活时间
                TimeUnit.SECONDS,//时间单位
                new ArrayBlockingQueue<>(3),//数组有界队里
                new ThreadPoolExecutor.AbortPolicy()//采用的拒绝策略是什么
        );
        //这边总共7个任务，2个线程执行任务，345进入队列，第六个线程启动最大线程数来执行，第七个任务触发拒绝策略
        for(int i=0;i<=6;i++){
            threadPoolExecutor.execute(new MyTask(i,"任务:"+i));
        }
        threadPoolExecutor.shutdown();
    }

}
```

* 线程池的执行流程

![1585730051663](/v-blog/img/java/middle-java/juc/1585730051663.png)

# 生产者消费者模型

```
生产者消费者模式是并发、多线程编程中经典的设计模式，生产者和消费者通过分离的执行工作解耦，简化了开发模式，生产者和消费者可以以不同的速度生产和消费数据。
```

- 结构图

![1585744148133](/v-blog/img/java/middle-java/juc/1585744148133.png)



```
* 生产者生产手机
* 消费者购买手机
* 角色定义
 - 产品信息：华为、小米
 - 产品的仓库：生产者往里面存、消费者从里面消费
 - 消费者
 - 生产者
 - 启动类
```



- 产品信息类：Product

```java
public class Product {

    private String name;
    private String from;//来自哪个生产者
    private int id = 0;

    public Product(String name, String from, int id) {
        this.name = name;
        this.from = from;
        this.id = id;
    }

    public Product(String name, String from) {
        this.name = name;
        this.from = from;
    }

    public String getName() {
        return name;
    }

    public String getFrom() {
        return from;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

}
```

- 产品的仓库:Storage

```java
public class Storage {

    //阻塞队列
    private BlockingQueue<Product> storage = new LinkedBlockingDeque<>();

    private int index = 1;//用于生成产品编号

    /**
     * 消费
     */
    protected void pop() throws InterruptedException {
        Product product = storage.take();
        System.out.println(product.getFrom() + "的" + product.getName() + "--> id:" + product.getId() + "被消费了");
    }

    /**
     * 生产
     */
    protected void push(Product product) throws InterruptedException {
        storage.put(product);
        product.setId(index++);
        System.out.println(product.getFrom() + ",生产了" + product.getName() + "--> id:" + product.getId());
    }


}
```

- 消费者:Consumer

```java
public class Consumer implements Runnable  {

    private Storage storage;

    public Consumer(Storage storage) {
        this.storage = storage;
    }

    @Override
    public void run() {
        try {
            while (true) {
                storage.pop();
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}

```

- 生产者:Producer

```java
public class Producer implements Runnable  {

    private String name;//生产者名称
    private String pname;//生产的产品
    private Storage storage;//仓库

    public Producer(String name, String pname, Storage storage) {
        this.name = name;
        this.pname = pname;
        this.storage = storage;
    }

    @Override
    public void run() {
        try {
            for (int i = 0; i < 15; i++) {
                Product p = new Product(pname, name);
                storage.push(p);
                Thread.sleep(100);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}
```

- 启动类

```java
public class BlockingQueueDemo {

    public static void main(String[] args) {
        BlockingQueueDemo pac = new BlockingQueueDemo();
        Storage storage = new Storage();
        Producer p1 = new Producer("生产者1", "小米手机", storage);
        Producer p2 = new Producer("生产者2", "华为手机", storage);
        Consumer c1 = new Consumer(storage);

        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.submit(p1);
        executorService.submit(p2);
        executorService.submit(c1);

    }

}
```

