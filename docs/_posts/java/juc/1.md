# 并发编程-传智播客



::: tip 提示
环境: jdk1.8 、IntelliJ IDEA 2019.3
:::

## Volatile关键字-内存可见性

> 如果字段加上volatile可以保持内存可见

优势：

- 比同步锁锁效率高

- 解决内存不可见的问题(可以理解为共享数据都在主内存中操作)

缺陷：

- 不具有互斥性

- 不能解决原子性问题

代码演示如下：

```java
/**
 * java.util.concurrent JUC
 *
 * Volatile关键字：
 * 当多个线程进行操作共享数据时，可以保证内存中的数据可见。
 * 相较于 synchronized 是一种轻量级的同步策略。
 *
 * 注意：
 * 1. volatile 不具有互斥性
 * 2. volatile 不能保证变量的原子性
 *
 * @author huwenfeng
 */
public class TestVolatile {

    public static void main(String[] args) {
        ThreadDemo td = new ThreadDemo();
        new Thread(td).start();
 
        while (true) {
            if (td.isFlag()) {
                System.out.println("----------");
                break;
            }
        }
    }
}

/**
 * flag 是一个共享数据
 * 内存可见性问题是，当多个线程操作共享数据时，彼此不可见。
 */
class ThreadDemo implements Runnable {

    private volatile boolean flag = false;

    public void run() {
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        flag = true;
        System.out.println("flag = " + isFlag());

    }

    public boolean isFlag() {
        return flag;
    }

    public void setFlag(boolean flag) {
        this.flag = flag;
    }
}
```



## 原子变量-CAS算法

### 原子性问题

> 详见：java.util.concurrent包下 AtomicInteger 等类

CAS算法： CompareAndSwap

优点：

- 直接利用计算机底层硬件

- 执行不会等待(不会阻塞)

- 性能比锁要好

缺点：

- 每次只能一个线程执行成功

代码演示：

```java
/**
 * 一、 i++ 的原子性问题； i++ 实际上分为'读'，'改'，'写'三个步骤
 *     int i = 10;
 *     i = i++;
 *
 *     int temp = 1;
 *     i = i + 1;
 *     i = temp;
 *
 * 二、原子变量：jdk1.5后 java.util.concurrent提供了相应的原子变量
 *     volatile ： 保证内存可见性
 *     CAS（CompareAndSwap）：硬件对于并发操作数据的支持
 *          CAS包含了三个操作数：
 *          内存值：V
 *          预估值：A
 *          更新值：B
 *          当且仅当V == A时，才把V = B，否则将不做任何操作。
 *
 * @author huwenfeng
 */
public class TestAtomicDemo {

    public static void main(String[] args) {
        AtomicDemo ad = new AtomicDemo();
        for (int i = 0; i < 10; i++) {
            new Thread(ad).start();
        }
    }
  
}


class AtomicDemo implements Runnable {

    //private int serialNumber;
    private AtomicInteger serialNumber = new AtomicInteger();

    public void run() {
        try {
            Thread.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("num: " + getSerialNumber());

    }

    public int getSerialNumber() {
        return serialNumber.getAndIncrement();
      
    }

}
```



### 模拟CAS

代码如下：

```java
/**
 * 模拟 CAS
 *
 * @author huwenfeng
 */
public class TestCompareAndSwap {

    public static void main(String[] args) {
        final CompareAndSwap cas = new CompareAndSwap();
        for (int i = 0; i < 10; i++) {
            new Thread(new Runnable() {
                public void run() {
                    int expectValue = cas.getValue();
                    boolean compareAndSet = cas.compareAndSet(expectValue, (int) (Math.random() * 101));
                    System.out.println("compareAndSet = " + compareAndSet);
                }
            }).start();
        }
    }
}


class CompareAndSwap {
    private int value;

    // 获取内存值
    public synchronized int getValue() {
        return value;
    }

    // 比较
    public synchronized int CompareAndSwap(int expectValue, int newValue) {
        int oldValue = value;

        if (oldValue == expectValue) {
            value = newValue;
        }

        return oldValue;
    }

    // 设值
    public synchronized boolean compareAndSet(int expectValue, int newValue) {
        return expectValue == CompareAndSwap(expectValue, newValue);
    }

}
```



## ConcurrentHashMap

ConcurrentHashMap特点：

- 线程安全的Hash表

- java1.7 锁分段技术，只会锁一部分数据,其他段的数据不会影响 ,性能优于同步锁

- java1.8 以后用的也是CAS算法，类似于锁的一种同步策略，性能优于锁



java.concurrent包相关容器特点:

当期望许多线程访问一个给定的Collection时，ConcurrentHashMap通常优与同步的HashMap，ConcurrentSkipListMap通常优于同步的TreeMap；

当期望的读数和遍历远远大于列表的更新数时，CopyOnWriteArrayList优与同步的ArrayList。(每次写入都会复制)





## CountDownLatch(闭锁)



>  CountDownLatch：是一个同步辅助类，在完成一组其他操作之前，它允许一个或多个线程一直等待。



闭锁可以延迟线程的进度直到其达到终止状态，闭锁可以用来确保某些活动直到其他活动都完成才继续执行：

- 确保某个计算在其需要的所有资源都初始化之后才继续执行;
- 确保某个服务在其依赖的所有其他服务都已经启动之后才启动；
- 等待直到某个操作所有参与者都准备就绪在继续执行。



示例：

```java
/**
 * CountDownLatch：闭锁，在完成某些运算时只有其他所有线程的运算全部完成，当前运算才继续执行。
 *
 * 示例：计算多线程执行时间
 * @author huwenfeng
 */
public class TestCountDownLatch {

    public static void main(String[] args) {
        final CountDownLatch latch = new CountDownLatch(5);
        LatchDemo ld = new LatchDemo(latch);

        long start = System.currentTimeMillis();

        for (int i = 0; i < 5; i++) {
            new Thread(ld).start();
        }

        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        long end = System.currentTimeMillis();

        System.out.println("耗费时间为： " + (end - start));
    }

}

class LatchDemo implements Runnable {

    private CountDownLatch latch;

    public LatchDemo(CountDownLatch latch) {
        this.latch = latch;
    }

    @Override
    public void run() {
        synchronized (this) {
            try {
                for (int i = 0; i < 50000; i++) {
                    if (i % 2 == 0) {
                        System.out.println("i = " + i);
                    }
                }
            } finally {
                latch.countDown();
            }
        }
    }
}
```



## 线程的创建

创建线程的方式：

- 继承 Thread 类

- 实现 Runnable 接口

- 实现 Callable 接口

- 线程池



通过实现 Callable 接口创建线程：

```java
/**
 * 一、创建线程方式三：实现Callable接口， 相较于实现Runnable接口的方式，方法可以有返回值，并且可以抛出异常。
 *
 * 二、执行Callable方式，需要FutureTask实现类的支持，用于接收运算结果，FutureTask是Future的实现类。
 *
 * @author huwenfeng
 */
public class TestCallable {

    public static void main(String[] args) {
        CallableThreadDemo ctd = new CallableThreadDemo();

        // 执行Callable 方式，需要FutureTask实现类的支持，用于接收运算结果
        FutureTask<Integer> result = new FutureTask<>(ctd);

        new Thread(result).start();

        // 接收线程运算后的结果
        try {
            // FutureTask 也可用于闭锁的操作 (等call方法的任务执行完毕才会执行下面的操作)
            Integer sum = result.get();
            System.out.println("sum = " + sum);
            System.out.println("------------");
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }

}

class CallableThreadDemo implements Callable<Integer> {

    @Override
    public Integer call() throws Exception {
        int sum = 0;

        for (int i = 0; i < Integer.MAX_VALUE; i++) {
            sum += i;
        }

        return sum;
    }
}
```



## Lock同步锁

解决多线程安全的方式：

- 同步代码块（隐式锁）

- 同步方法（隐式锁）

- 同步锁 Lock (显示锁)  jdk1.5 以后



演示同步锁的用法：

```java
/**
 * 一、用于解决多线程线程安全问题的方式
 * synchronized：隐式锁
 * 1. 同步代码块
 * 2. 同步方法
 *
 * jdk1.5以后：
 * 3. 同步锁Lock
 * 注意：是一个显示锁，需要通过lock() 方法上锁，必须通过unlock() 方法进行释放锁。
 * 必须要保持 unlock()方法执行(通常放在finally里)
 *
 * @author huwenfeng
 */
public class TestLock {

    public static void main(String[] args) {
        Ticket ticket = new Ticket();

        new Thread(ticket, "1号窗口").start();
        new Thread(ticket, "2号窗口").start();
        new Thread(ticket, "3号窗口").start();
    }

}

class Ticket implements Runnable {

    private int tick = 100;

    private Lock lock = new ReentrantLock();

    @Override
    public void run() {
        while (tick > 0) {
            lock.lock();
            try {
                System.out.println(Thread.currentThread().getName() + " 完成售票，余票为：" + --tick);
            } finally {
                lock.unlock();
            }
        }
    }
}
```



生产者消费者案例：

```java
/**
 * 生产者消费者模型
 * 同步锁
 * 等待唤醒机制
 * 虚假唤醒
 *
 * @author huwenfeng
 */
public class TestProductAndConsumer {

    public static void main(String[] args) {
        Clerk clerk = new Clerk();
        Productor productor = new Productor(clerk);
        Consumer consumer = new Consumer(clerk);

        new Thread(productor, "生产者A").start();
        new Thread(productor, "生产者B").start();
        new Thread(consumer, "消费者A").start();
        new Thread(consumer, "消费者B").start();
    }

}

// 店员
class Clerk {
    private int product = 0;

    // 进货
    public synchronized void get() {
        // 为了避免虚假唤醒问题 应该总是在循环中使用
        while (product >= 1) {
            System.out.println("产品已满");

            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            
        }
        
        System.out.println(Thread.currentThread().getName() + " : " + ++product);
        this.notifyAll();
    }

    // 卖货
    public synchronized void sale() {
        while (product <= 0) {
            System.out.println("缺货！");

            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }

        System.out.println(Thread.currentThread().getName() + " : " + --product);
        this.notifyAll();
    }
}

// 生产者
class Productor implements Runnable {
    private Clerk clerk;

    public Productor(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            clerk.get();
        }
        
    }
}

// 消费者
class Consumer implements Runnable {
    private Clerk clerk;

    public Consumer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            clerk.sale();
        }
    }
}
```



## Condition控制线程通讯

相较于Object中的等待唤醒：

| 对象      | 等待    | 唤醒某个 | 唤醒所有    |
| --------- | ------- | -------- | ----------- |
| Object    | wait()  | notify() | notifyAll() |
| Condition | await() | signal() | signalAll() |



Condition特点：

- 单个Lock可能与多个Condition对象关联。(**详见文末面试题**)

- Condition实例实质上被绑定到一个锁上。

- 要为特定Lock实例获得Condition实例，请使用其newCondition()方法。(详见如下代码示例)



Condition改造生产者消费者模型代码示例：

```java
/**
 * 生产者消费者模型
 * Lock 结合Condition 完成等待唤醒
 *
 * @author huwenfeng
 */
public class TestProductAndConsumerForLock {

    public static void main(String[] args) {
        Clerk clerk = new Clerk();
        Productor productor = new Productor(clerk);
        Consumer consumer = new Consumer(clerk);

        new Thread(productor, "生产者A").start();
        new Thread(productor, "生产者B").start();
        new Thread(consumer, "消费者A").start();
        new Thread(consumer, "消费者B").start();
    }

}

// 店员
class Clerk1 {
    private int product = 0;

    public Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    // 进货
    public void get() {
        lock.lock();

       try {
           // 为了避免虚假唤醒问题 应该总是在循环中使用
           while (product >= 1) {
               System.out.println("产品已满");

               try {
                   condition.await();
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }

           }

           System.out.println(Thread.currentThread().getName() + " : " + ++product);
           condition.signalAll();
       } finally {
           lock.unlock();
       }

    }

    // 卖货
    public void sale() {
        lock.lock();

        try {
            while (product <= 0) {
                System.out.println("缺货！");

                try {
                    condition.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }

            System.out.println(Thread.currentThread().getName() + " : " + --product);
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }
}

// 生产者
class Productor1 implements Runnable {
    private Clerk clerk;

    public Productor1(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            clerk.get();
        }

    }
}

// 消费者
class Consumer1 implements Runnable {
    private Clerk clerk;

    public Consumer1(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            clerk.sale();
        }
    }
}
```



## 线程八锁

> 核心：
>
> - 非静态方法的锁默认为 this，静态方法的锁默认为对应Class对象
>
> - 某一时刻内，只能有一个线程持有锁，无论有几个方法。



代码演示：

```java
/**
 * 题目：判断打印 "one" or "two"
 *
 * 1. 两个普通同步方法，两个线程，标准打印，打印？ // one two
 * 2. 在getOne方法中新增Thread.sleep()，打印？ // one two
 * 3. 新增普通方法getThree()， 打印？ // three one two
 * 4. 两个普通同步方法，两个number对象， 打印？ // two one
 * 5. 修改getOne() 为静态同步方法， 打印？ // two one
 * 6. 修改两个方法为静态同步方法，一个number对象，打印? // one two
 * 7. 一个静态同步方法，一个普通同步方法，两个number对象， 打印？ // two one
 * 8. 两个静态同步方法，两个number对象？ // one two
 *
 * 线程八锁的关键：
 * 1. 非静态方法的锁默认为 this，静态方法的锁默认为对应Class对象
 * 2. 某一时刻内，只能有一个线程持有锁，无论有几个方法。
 *
 * @author huwenfeng
 */
public class TestThread8Monitor {

    public static void main(String[] args) {
        Number number = new Number();
        Number number2 = new Number();

        new Thread(new Runnable() {
            @Override
            public void run() {
                number.getOne();
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                number2.getTwo();
            }
        }).start();

//        new Thread(new Runnable() {
//            @Override
//            public void run() {
//                number.getThree();
//            }
//        }).start();
    }
}

class Number {

    public static synchronized void getOne() {

        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("one");
    }

    public static synchronized void getTwo() {
        System.out.println("two");
    }

    public void getThree() {
        System.out.println("three");
    }

}
```



## ReadWriteLock-读写锁

ReadWriteLock：

- 不同线程同时   写-写 操作   互斥

- 不同线程同时   读-写操作    互斥

- 不同线程同时   读-读操作    不互斥



代码演示：

```java
/**
 * 读写锁
 *
 * 1. ReadWriteLock：读写锁
 * 写写/读写需要互斥   写锁独享
 * 读读 不互斥    读锁可以共享
 *
 * @author huwenfeng
 */
public class TestReadWriteLock {

    public static void main(String[] args) {
        ReadWriteLockDemo rw = new ReadWriteLockDemo();
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                rw.set((int) (Math.random() * 101));
            }
        }, "Write").start();

        for (int i = 0; i < 100; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    rw.get();
                }
            }, "Read").start();
        }
    }

}

class ReadWriteLockDemo {

    private int number = 0;

    private ReadWriteLock lock = new ReentrantReadWriteLock();

    // 读
    public void get() {
        lock.readLock().lock();

        try {
            System.out.println(Thread.currentThread().getName() + ": " + number);
        } finally {
            lock.readLock().unlock();
        }

    }

    // 写
    public void set(int number) {
        lock.writeLock().lock();

        try {
            this.number = number;
            System.out.println(Thread.currentThread().getName() + ": " + number);
        } finally {
            lock.writeLock().unlock();
        }

    }

}
```



## 线程池与线程调度

线程池：

> java.util.concurrent.Executor

线程调度：

> java.util.concurrent.ScheduledExecutorService

Executors工具类可以直接操作

操作演示：

```java
/**
 * 一、 线程池：提供了一个线程队列，队列中保存着所有等待状态的线程，避免了创建与销毁的额外开销，提高了响应的速度。
 *
 * 二、 线程池的体系结构：
 *      java.util.concurrent.Executor ：线程的使用和调度的跟接口
 *          |-- ExecutorService 子接口：线程池的主要接口
 *              |--ThreadPoolExecutor：实现类
 *              |--ScheduledExecutorService：子接口：负责线程的调度
 *                  |--ScheduledThreadPoolExecutor：继承 ThreadPoolExecutor、实现 ScheduledExecutorService
 *
 * 三、 工具类：Executors
 * ExecutorService newFixedThreadPool() ：创建固定大小的线程池
 * ExecutorService newCachedThreadPool() ：缓存线程池，线程池的数量不固定，可以根据需求来自动的更改数量
 * ExecutorService newSingleThreadPool() ：创建单个线程的线程池
 *
 * ScheduledExecutorService newScheduledThreadPoll() ：创建固定大小的线程池，可以延迟或者定时的执行任务
 *
 *
 * @author huwenfeng
 */
public class TestThreadPool {

    public static void main(String[] args) {
        // 创建线程池
        ExecutorService pool = Executors.newFixedThreadPool(5);

//        ThreadPoolDemo tp = new ThreadPoolDemo();
//        for (int i = 0; i < 100; i++) {
//            // 为线程池中的线程分配任务
//            pool.submit(tp);
//        }

        Future<Integer> future = pool.submit(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                int sum = 0;

                for (int i = 0; i < 100; i++) {
                    sum += i;
                }

                return sum;
            }
        });

        Integer sum = 0;
        try {
            sum = future.get();
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
        System.out.println("sum = " + sum);

        // 关闭线程池(等线程中的任务执行完毕在关闭线程池)
        pool.shutdown();

    }

}


class ThreadPoolDemo implements Runnable {
    private int i = 0;

    @Override
    public void run() {
        while (i <= 100) {
            System.out.println(Thread.currentThread().getName() + " : " + i++);
        }
    }
}

/**
 * 线程调度
 */
class ScheduleThreadPoolDemo {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ScheduledExecutorService pool = Executors.newScheduledThreadPool(5);

        for (int i = 0; i < 3; i++) {
            ScheduledFuture<Integer> future = pool.schedule(new Callable<Integer>() {
                @Override
                public Integer call() throws Exception {
                    // 生成随机数
                    int num = new Random().nextInt(100);
                    System.out.println(Thread.currentThread().getName() + " : " + num);
                    return num;
                }
            }, 3, TimeUnit.SECONDS);
            System.out.println("future.get() = " + future.get());
        }

        // 关闭
        pool.shutdown();

    }

}
```



















## Fork/Join框架/ParallelStream

Fork/Join框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务(拆到不可再拆分时)，再将一个个小任务运算的结果进行join汇总。



核心内容：

就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务(拆到不可再拆时)，再将一个个的小任务运算的结果进行join汇总。

- 工具窃取模式

- 进一步利用CPU资源，提高CPU利用率

- 操作依赖 java.util.concurrent.ForkJoinPool

- 先任务拆分Fork成多个任务  并行执行

- 最后在将各个任务计算的接口整合Join在一起



Fork/Join 普通For Java8并行流求和对比:

```java
/**
 * ForkJoin框架
 *
 * @author huwenfeng
 */
public class TestForkJoinPool {

    public static void main(String[] args) {
        Instant start = Instant.now();
        ForkJoinPool pool = new ForkJoinPool();

        ForkJoinTask<Long> task = new ForkJoinSumCalculate(0L, 50000000000L);

        Long sum = pool.invoke(task);

        Instant end = Instant.now();
        // 4705
        // -4378596987249509888
        System.out.println("耗时：" + Duration.between(start, end).toMillis());
        System.out.println("sum = " + sum);

    }

    @Test
    public void testFor() {
        Instant start = Instant.now();

        long sum = 0L;

        for (long i = 0L; i <= 50000000000L; i++) {
            sum += i;
        }

        Instant end = Instant.now();

        // 12932
        // -4378596987249509888
        System.out.println("耗时：" + Duration.between(start, end).toMillis());
        System.out.println("sum :" + sum);

    }

    @Test
    public void testJava8() {
        Instant start = Instant.now();
        long sum = LongStream.rangeClosed(0L, 50000000000L)
                .parallel()
                .reduce(0L, Long::sum);
        // 3215
        // -5340232216128654848
        System.out.println("耗时: " + Duration.between(start, Instant.now()).toMillis());
        System.out.println("sum = " + sum);
    }
}

class ForkJoinSumCalculate extends RecursiveTask<Long> {

    private long start;

    private long end;

    /**
     * 临界值
     */
    private static final long CRITICAL_VALUE = 100000000L;

    public ForkJoinSumCalculate(long start, long end) {
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        long length = end - start;

        if (length <= CRITICAL_VALUE) {
            long sum = 0L;

            for (long i = start; i <= end; i++) {
                sum += i;
            }

            return sum;

        } else {
            long middle = (start + end) / 2;
            ForkJoinSumCalculate left = new ForkJoinSumCalculate(start, middle);
            // 拆分
            left.fork();

            ForkJoinSumCalculate right = new ForkJoinSumCalculate(middle + 1, end);
            right.fork();

            return left.join() + right.join();

        }

    }
}
```



## 面试题: 线程按序交替打印

题目：编写一个程序，开启3个线程，这三个线程的ID分别为A、B、C，每个线程将自己的ID在屏幕上打印10遍,要求输出的结果必须按序显示.

如: ABCABCABCABC....... 依次递归。

代码如下：

```java
/**
 * 题目：编写一个程序，开启3个线程，这三个线程的ID分别为A、B、C，
 * 每个线程将自己的ID在屏幕上打印10遍,要求输出的结果必须按序显示.
 *
 * 如: ABCABCABCABC....... 依次递归。
 *
 * @author huwenfeng
 */
public class TestABCAlternate {
    public static void main(String[] args) {

        AlternateDemo alternateDemo = new AlternateDemo();

        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 20; i++) {
                    alternateDemo.loopA();
                }
            }
        }, "A").start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 20; i++) {
                    alternateDemo.loopB();
                }
            }
        }, "B").start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 20; i++) {
                    alternateDemo.loopC();
                }
            }
        }, "C").start();

    }

}

class AlternateDemo {

    private int number = 1;

    private Lock lock = new ReentrantLock();
    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();

    public void loopA() {
        lock.lock();
        try {
            // 判断是否打印
            if (number != 1) {
                try {
                    // 等待
                    condition1.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            System.out.print("A");

            // 唤醒其他程序执行
            number = 2;
            condition2.signal();
        } finally {
            lock.unlock();
        }

    }

    public void loopB() {
        lock.lock();
        try {
            if (number != 2) {
                try {
                    condition2.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            System.out.print("B");

            // 唤醒其他程序执行
            number = 3;
            condition3.signal();

        } finally {
            lock.unlock();
        }
    }

    public void loopC() {
        lock.lock();
        try {
            if (number != 3) {
                try {
                    condition3.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            System.out.print("C");

            // 唤醒其他程序执行
            number = 1;
            condition1.signal();
        } finally {
            lock.unlock();
        }

    }

}
```





