# Java泛型

## 泛型需要了解哪些？

![JAVA泛型](/v-blog/img/java/middle-java/jdk/genric/JAVA泛型.png)





### 泛型类

```java
public class FanxingClass<T> {
  private T t;
  
  public Fanxing(T t) {
    this.t = t;
  }
  
  // 这个并不是泛型方法，只是一个使用了泛型的泛型类的成员方法
  public T getValue(){
    return t;
  } 
}
```



### 泛型接口

```java
public interface FanXingIterface<T> {
  
  public T getValue() {
    return t;
  }
  
}
```



### 泛型方法

```java
public <T> T get
```



### 泛型通配符

​	<?>                       无限制通配符             

​	<? extends T>    上限通配符

​    <? super T>        下限通配符



### 泛型擦除技术

​	基本擦除 -> 直接替换成Object

​	有界擦除 -> 替换成上界

​	桥接方式 -> 方法内部实现





## 泛型技术

### 泛型的引入

泛型是什么？

- 参数化类型， 类型参数

为什么要使用泛型？

- 提高了代码的复用性
- 提高程序的可读性和安全性

如何使用泛型？

- 泛型类
- 泛型方法
- 泛型通配符

集合是一个容器，可以保存对象。集合中是可以保存任意类型的对象。

```java
List list = new ArrayList();
list.add(“abc”); //保存的是字符串对象
list.add(123); //保存的是Integer对象
```

​		如果使用原生类型，那么对象保存到集合中，都会被提升成Object类型。取出的一定也是Object类型，就发生多态了。如要使用保存的对象的特有方法或者属性时，需向下转型(有风险)。还得使用 instanceof关键字进行判断，使用起来相对麻烦。

​		而数组这类容器在定义好之后，类型就已经确定，如果保存的数据类型不一致，编译直接报错。数组是个容器，集合也是容器，数组可以在编译的时候就能检测数保存的数据类型有问题，如果我们在定义集合的时候，也让集合中的数据类型进行限定，然后在编译的时候，如果类型不匹配就不让编译通过， 那么运行的时候也就不会发生ClassCastException。

 		要做到在向集合中存储数据的时候限定集合中的数据类型，也就是说编译的时候会检测错误。java中从JDK1.5后提供了一个新的技术，可以解决这个问题：**泛型技术**。



### 泛型技术介绍

泛型的格式： <具体的数据类型>

使用格式： ArrayList<限定集合中的数据类型> list = new ArrayList<限定集合中的数据类型>();

说明：给集合加泛型，就是让集合中只能保存具体的某一种数据类型。



**小结：**

一、 泛型的好处？

1）解决了集合中存储数据的不安全性；

2）把运行时可能发生的异常，放在编译时作为编译错误处理了，避免了运行时的异常；

3）省略了代码中的强制类型转换的书写；

二、注意事项：

1）泛型只支持引用数据类型(类类型或接口类型等)，泛型不支持基本数据类型：       

2）泛型不支持数据类型以继承的形式存在，要求前后泛型的数据类型必须一致：        

3）在jdk1.7后的类型推断, 泛型也可用如下写法：`ArrayList<String> list = new ArrayList<>()`

4）泛型兼容老版本，但是尽量避免，不建议的写法：`ArrayList<String> list = new ArrayList()`

**注意：现在的开发中，泛型已经成为编写代码的规范。**



### 类型擦除技术

   泛型是Java 1.5版本才引进的概念，在这之前是没有泛型的，但是，泛型代码能够很好地和之前版本的代码兼容。那是因为，泛型信息只存在于代码编译阶段，在进入JVM之前，与泛型相关的信息会被擦除掉，我们称之为--类型擦除。

无限制类型擦除：

![image-20200418110448595](/v-blog/img/java/middle-java/jdk/genric/image-20200418110448595.png)

有限制类型擦除：

![image-20200418110511025](/v-blog/img/java/middle-java/jdk/genric/image-20200418110511025.png)

擦除方法中定义的类型参数：

![image-20200418110605919](/v-blog/img/java/middle-java/jdk/genric/image-20200418110605919.png)

桥接方法：

![image-20200418110638956](/v-blog/img/java/middle-java/jdk/genric/image-20200418110638956.png)

 

## 自定义泛型

### 泛型的定义介绍

​		在集合中，不管是接口还是类，它们在定义的时候类或接口名的后面都使用<标识符>，当我们在使用的时候，可以指定其中的类型。

泛型自定义格式：<标识符>

​       这里的标识符可以是任意的字母、数字、下划线和 $ 。但是这里一般规范使用单个大写字母。

注意：自定义泛型也属于标识符，满足标识符的命名规则。1）数字不能开始；2）关键字不能作为标识符；

### 自定义泛型类

泛型类：  在定义类的时候，在类名的后面书写泛型。

格式：

  ```java
class 类名<泛型参数>
{
}
// 泛型参数其实就是标识符。
  ```

说明：

1）在类上定义的泛型，在创建这个类的对象的时候，需要创建者自己来明确当前泛型的具体类型；

 2）在类上定义的泛型，在类中的方法上和成员变量是可以使用的；

 3）如果创建类的对象时没有指定泛型类型，默认是Object类型，指定了就是指定的类型；



### 泛型方法

​		虽然可以在类上定义泛型，但是有时类中的方法需要接收的数据类型和类上外界指定的类型不一致。也就是说对于某个函数而言参数的数据类型和所属类的泛型类型不一致了，这时我们可以在这个类中的这个方法上单独给这个方法设定泛型。

  在函数上使用泛型的格式：

```java
 函数修饰符 <泛型名>  函数返回值类型 方法名( 泛型名 变量名 )
 { 
   函数体;
 }
public <T> T getT(T t) {
  // do something
}
```

说明：函数返回值类型前面的<泛型名>相当于定义了方法参数列表中泛型的类型。

总结：

​    1）自定义泛型方法格式：`修饰符 <泛型> 返回值 函数名(参数列表 ){}`

​    2）自定义泛型方法，泛型必须在函数返回值之前和函数修饰之后定义，否则报错；

​    3）泛型方法中泛型的确定：在方法被调用的时候，传递参数的时候才确定；

注意事项：

- 静态方法上的泛型：静态方法不能使用类上定义的泛型。（请使用自定义泛型方法）

- 因为静态方法运行不需要对象，而类上的泛型必须在创建这个类对象的时候才能明确具体是什么类型。

- 而静态函数运行的时候是没有对象的，也就是说类上的泛型在静态函数运行的时候还不知道是什么类型。



### 泛型接口和泛型传递

通过查阅API得知，类支持泛型，那么接口也可以支持泛型，比如集合中的接口。

泛型接口的格式：

修饰符 interface 接口名<泛型>{}

泛型是支持传递的。

 

### 泛型通配符

? 表示任意类型。

- 用于方法的形参上。

- 解决集合中不可协变的问题(数组可以协变，类似于多态)。

注意：泛型的通配符虽可简化代码的开发，但开发中要慎用，如果用通配符，函数就可接收任意数据类型，会导致代码不安全。如果想使用泛型的通配符必须使用通配符的限定。目的是考虑数据的安全性。



### 泛型限定

解决集合中不可协变的问题(数组可以协变，类似于多态)

#### 上限限定

上限限定的格式：<？ extends 父类类型或父接口类型>

例如：<？ extends Person> ：

？代表的是一种类型，当前这个类型可以是Person本身，也可以是Person的子类。

#### 下限限定

下限限定格式： <？ super 子类类型或实现类类型>

例如：< ？ super Student >：

？代表当前的类型可以是Student类型，也可以是Student的父类类型。

但不能是Student 的子类，或者Student的兄弟。



#### 阿里规约泛型限制

【强制】泛型通配符<?extendsT>来接收返回的数据，此写法的泛型集合不能使用add方 法，而<? super T>不能使用 get 方法，作为接口调用赋值时易出错。
 说明:扩展说一下 PECS(Producer Extends Consumer Super)原则:第一、频繁往外读取内容的，适合 用<? extends T>。第二、经常往里插入的，适合用<? super T>

【强制】在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行 instanceof 判断，避免抛出 ClassCastException 异常。
 说明:毕竟泛型是在 JDK5 后才出现，考虑到向前兼容，编译器是允许非泛型集合与泛型集合互相赋值。

 

